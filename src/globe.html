<html>
    <head>
        <title>Itowns - Globe</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../../itowns/examples/css/LoadingScreen.css">
        <link rel="stylesheet" type="text/css" href="scene2d.css">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
        <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js"></script>  
    </head>

    <body>  

        <div id="viewerDiv">        
                <p id="info">
                        <img id="imgLogo" src="../data/logoAlegoria.jpg" onmousedown="getImgCoordOnClick(event)">
                        <br> 
                        <a href="http://www.archives-nationales.culture.gouv.fr/" target="_blank"> Images: Archives Nationales </a>
                </p>
                <div class="container" id="containerIMG" style="display: grid;
                                                            color: white;
                                                            position: absolute;
                                                            bottom: 0;
                                                            right: 0;
                                                            border: 0px white solid; 
                                                            height:194px; 
                                                            width: 100%;
                                                            margin: 0;
                                                            padding: 0;
                                                            overflow: auto;
                                                            overflow-y: hidden;">
                                                            <table id="myTable">
                                       
                                                            </table>
                </div> 

            <button id="buttonHideShow" class="styleButton" onclick="hideShow()">_</button>

            <div id="miniDiv">
                <img id="img"  onmousedown="getImgCoordOnClick(event)">
            </div>


        </div>


        <div class="gotolocation" tabindex="-1">
            <input type="text" id="nameLocation" name="name" required minlength="1" size="20">
        </div>
    

        <form class="styleForm" method="post" enctype="multipart/form-data">
            <input type="file" name="files[]" multiple>
            <input type="submit" value="Upload File" name="submit">
            <p  class="imageholder" id="countPoints"> Points registered: 0</p>
            <button class="buttonX" type="button" onclick="computeResection(event, document.getElementById('img').src.split('/').pop(), true)">Go</button>
        </form>
        <div id="metaData" class = "metaDataDisplay"></div>
        <div id="filtrage">
            <label class="switch">
             
                <input id= "switchButton" type="checkbox" onchange="filterThumbnails()">
                <span class="sliders round"></span>
          </label>
        </div>

        <script src="../../itowns/examples/js/GUI/GuiTools.js"></script>
        <script src="../../itowns/dist/itowns.js"></script>
        <script src="../../itowns/examples/js/GUI/LoadingScreen.js"></script>
        <script src="../../itowns/examples/js/plugins/FeatureToolTip.js"></script>
        <script src="../../photogrammetric-camera/dist/three-photogrammetric-camera.js"></script>
        <!--    <script src="../../itowns/examples/js/ThreeLoader.js"></script>   -->
        <script src="../../itowns/dist/debug.js"></script>
        <script src="scene2d.js"></script>
        <script src="scene3dv2.js"></script>
        <script src="createCalibrationFile.js"></script>
        <script src="createMicmacChantierDescripteur.js"></script>


        <script type="text/javascript">
            
            // THREE photogrammetric camera variables
            var PhotogrammetricCamera = ThreePhotogrammetricCamera.PhotogrammetricCamera; //three-photogrammetric-camera.PhotogrammetricCamera;
            var MicmacOrientationParser = ThreePhotogrammetricCamera.MicmacOrientationParser;
            var FetchSource = ThreePhotogrammetricCamera.FetchSource;
            var OrientedImageMaterial = ThreePhotogrammetricCamera.OrientedImageMaterial;
            var RadialDistortion = ThreePhotogrammetricCamera.RadialDistortion;
            var THREE = itowns.THREE; //ThreePhotogrammetricCamera.THREE; // itowns.THREE;


            // Get possible parameters from url like imagename
            var urlpage = new URL(location);
            var imName = urlpage.searchParams.get("imgname");
            var posInit = urlpage.searchParams.get("pos");
            var wfsInURL = urlpage.searchParams.get("wfs");
            if(posInit) posInit = posInit.split(",");

            var defaultWFSCamera = 'alegoriaMerge2'; // 'alegoria5';
            //console.log(imName, "  ", posInit);

            var orientedImageLayer;
            
            var pictureInfos;
            var camera;
            var camHelper;
            var plane;
            var orientedImage;
            var orientedImageGUI;
            var orientedMenu = false;
            var currentIndiceNav = 0;
            var currentImageName = "";
            var globalCurrentCamOriented;
            var currentOrientationWorkedImage = "x";
            var currentCameraScene;
            var meshes = [];
            var scaler;
            var textureMaterial = new OrientedImageMaterial({
                    map: new itowns.THREE.TextureLoader().load('../data/uv.jpg'),
                    transparent:true
                });
            var currentOpacity = 1;
            var currentDistance = 350;
            var arrDisplayedImages = [];
            var meshesForeverever = [];
            var previewOn = false;
            var nearProj = 1;
            var farProj = 500;
            var target;
            var olayer;  // Oriented Image Layer
            var model; // 3D model loaded
            var arrAppariement = [];
            var currentObjUnderMouse;
            var lastObjUnderMouse;
            var firstMoveOut = false; // when mouse over leave camerahelper
            var scaleOff = false;
            var nbToModify = 0;  // Ugly init for animation
            var scalingOffisOn = false;
            var lowResValue = 128;
            var highResValue = 2048;
            var arrLoadedCameraNames = [];
            var previewModeOn = false;  // To handle the loading of super low resolution image like 128*128
            var mouseDown = false;
            var positionMouseDown = new THREE.Vector2();
            var mouseWheelOn = false;
            var imageSourcesInfo; // Object created at initialization getting infos through WFS on images url and other stuff
            var imageSourcesInfoDico = {};
            var currentDATADirectory = "../data";
            // Images from Archives Nationales
            var imagesArchivesDico = {}; 
            var currentSource = 10;  // Name of the source of the image we register (alex (10) is default, other can be archives_nationales  (5) for example)

            var thumbnailWidth = 300;
            var thumbnailHeight = 165;

            // var arrAppariementScene = [];
            // var arrAppariementOld = [];

            // Alex modifications to handle multiple images
            var arrayImages = [];
            arrayImages = [{image: '1957_DUR_452_0007.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0009.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0010.jpg', distance: 600, opacity: 1, plane:null},
            {image: '1957_DUR_452_0011_1.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0012.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0013.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0014.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0015.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0016.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0017.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0018.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0019.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0020.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0021.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1957_DUR_452_0022.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'pontlouisphilippe.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1919_CAF_C-1_0012.jpg', distance: 350, opacity: 1, plane:null}, 
            {image: '1951_DUR_208_0007.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1951_DUR_214_0024.jpg', distance: 350, opacity: 1, plane:null}, 
            {image: '1951_DUR_214_0022.jpg', distance: 350, opacity: 1, plane:null},
            {image: '1919_CAF_Z-36_0008.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'trocadero2.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'FRAN_0207_3299_L.jpg', distance: 350, opacity: 1, plane:null},
            {image: 'FRAN_0207_0648_L.jpg', distance: 350, opacity: 1, plane:null}];
            if(imName !== null)
                arrayImages.unshift(  {image: imName, distance: 350, opacity: 1, plane:null} );
            
            // Define initial camera position  // 43.9542987,6.5115427 44.1751125,6.3516113,222m 44.1748836,6.3511125
            // var positionOnGlobe = { longitude: 2.3186303566461626, latitude: 48.86426741804917, altitude: 188.94939874485135 };
            // 42.7211829,1.8392353
            // 48.8365154,-3.3129326 ( rocher de la sentinelle)   // fprca: 43.9595975,5.7772372,

            itowns.proj4.defs('EPSG:2154', '+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
            var positionOnGlobe = { longitude:-2.238466, latitude: 46.96861820, altitude: 800 };
            if(posInit){ positionOnGlobe.longitude =  Number(posInit[1]); positionOnGlobe.latitude = Number(posInit[0]), positionOnGlobe.altitude =  Number(posInit[2]) || positionOnGlobe.altitude; }
            //console.log(positionOnGlobe);
            //var miniView;
            var minDistance = 10000000;
            var maxDistance = 30000000;
            var meshes = [];
            // `viewerDiv` will contain iTowns' rendering area (`<canvas>`)
            var viewerDiv = document.getElementById('viewerDiv');
            //var miniDiv = document.getElementById('miniDiv');

            // Instanciate iTowns view
            var placement = {
                    coord: new itowns.Coordinates('EPSG:4326',  positionOnGlobe.longitude , positionOnGlobe.latitude),
                    range: positionOnGlobe.altitude,
                    tilt: 45,
                    heading: -60
            };
            var view = new itowns.GlobeView(viewerDiv, placement,{handleCollision: false, disableSkirt: false, noControls: false});
            view.camera.camera3D.near = 0.4;

            var sceneAllCams = new THREE.Object3D();  // Object containg all oriented images cam
            view.scene.add(sceneAllCams);

            setupLoadingScreen(viewerDiv, view);

            //3D point number
            var ptname = 0;
            loadImageSources();

            $(document).ready(function() {
                $("#containerIMG").mousewheel(function(e, delta) {
                this.scrollLeft -= (delta * 200);
                //e.preventDefault();
                });
            });

            function hideShow() {
                var x = document.getElementById("img");
                var button = document.getElementById("buttonHideShow");
                if (x.style.display === "none") {
                    x.style.display = "block";
                    button.innerHTML = '_';
                } else {
                    x.style.display = "none";
                    button.innerHTML = 'â–¢';
                }
            }

            // Filter between georeferenced and not georeferenced images
            function filterThumbnails(){
                var isChecked = document.getElementById("switchButton").checked;  
                var table = document.getElementById('myTable');
                var nbRows = table.rows.length;
                let currentRow = table.rows[0];
                //console.log(currentRow);

                // GET THE CELLS COLLECTION OF THE CURRENT ROW.
                var objCells = currentRow.cells;
                var display = "display:none;"

                if(!isChecked){
                    display = 'table-row';
                }

                // LOOP THROUGH EACH CELL OF THE CURENT ROW TO READ CELL VALUES.
                for (var j = 0; j < objCells.length; j++) {
                   console.log(objCells[j].innerHTML);
                   if(!objCells[j].innerHTML.includes("style"))  // Ugly way to detect georeferenced image because they have style for border
                        objCells[j].style = display;
                   
                }

            }

            //testGeocoding("bordeaux");

            // Add one imagery layer to the scene
            // This layer is defined in a json file but it could be defined as a plain js
            // object. See Layer* for more info.
            itowns.Fetcher.json('../../itowns/examples/layers/JSONLayers/Ortho.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ColorLayer('Ortho', config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });

/*          // USA ORTHO WMTS
            itowns.Fetcher.json('../itowns-photogrammetric-camera/examples/layers/JSONLayers/us.json').then(function _(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layerUS = new itowns.ColorLayer('USGS', config);
                view.addLayer(layerUS).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            });
*/
            // Add two elevation layers.
            // These will deform iTowns globe geometry to represent terrain elevation.
            function addElevationLayerFromConfig(config) {
                config.source = new itowns.WMTSSource(config.source);
                var layer = new itowns.ElevationLayer(config.id, config);
                view.addLayer(layer).then(menuGlobe.addLayerGUI.bind(menuGlobe));
            }
            itowns.Fetcher.json('../../itowns/examples/layers/JSONLayers/WORLD_DTM.json').then(addElevationLayerFromConfig);
            itowns.Fetcher.json('../../itowns/examples/layers/JSONLayers/IGN_MNT_HIGHRES.json').then(addElevationLayerFromConfig);
            
            
            var menuGlobe = new GuiTools('menuDiv', view);

            
            var meshes = [];
            var color = new itowns.THREE.Color();
            function altitudeBuildings(properties) {
                //console.log(properties.z_min, properties.hauteur);
                return properties.z_min - properties.hauteur - 3;
            }

            function extrudeBuildings(properties) {
                if (properties.id.indexOf('bati_remarquable') === 0) 
                    return properties.hauteur;
                    else
                    return properties.hauteur; // + 20;
            }

            function acceptFeature(properties) {
                return !!properties.hauteur;
            }

            
            function colorBuildings(properties) {
                if (properties.id.indexOf('bati_remarquable') === 0) {
                    return color.set(0x5555ff);
                } else if (properties.id.indexOf('bati_industriel') === 0) {
                    return color.set(0xff5555);
                }
                return color.set(0xeeeeee);
            }


            function testGeocoding(lieudit){

                var url = "https://wxs.ign.fr/an7nvfzojv5wa96dsga5nk8w/look4/user/search?indices=locating&method=prefix&types=address%2Cposition%2Ctoponyme%2Cw3w&nb=1&match%5Bfulltext%5D="+ lieudit;
                
                fetch(url)
                .then((response) => {
                    return response.json();
                })
                .then((myJson) => {
                   // console.log(myJson);

                    var coordArray = myJson.features[0].geometry.coordinates;
                    console.log(coordArray);
                    var pathTravel = [];
                    var timeTravel = 5000;
                    pathTravel.push({ range: 100000, time: timeTravel/2 , tilt: 80, heading: -50});
                    pathTravel.push({ coord: new itowns.Coordinates('EPSG:4326', coordArray[0], coordArray[1]), range: 50000, time: timeTravel });
                    pathTravel.push({ range: 1400, time: timeTravel , tilt: 50, heading: -110 });
                    travel(pathTravel);
                });

            }
            
            function travel(pathTravel) {
                var camera = view.camera.camera3D;
                return itowns.CameraUtils.sequenceAnimationsToLookAtTarget(view, camera, pathTravel);
            }

            function modifyAppearance(mesh){

              //  mesh.material = [mesh.material,new itowns.THREE.MeshBasicMaterial({wireframe:true})];
            }

            scaler = function update(/* dt */) {
                var i;
                var mesh;
                if (meshes.length) {
                    view.notifyChange(view.camera.camera3D, true);
                }
                for (i = 0; i < meshes.length; i++) {
                    mesh = meshes[i];
                    if (mesh) {
                        mesh.scale.z = Math.min(
                            1.0, mesh.scale.z + 0.1);
                        mesh.updateMatrixWorld(true);
                    }
                }
                meshes = meshes.filter(function filter(m) { return m.scale.z < 1; });
            };

            view.addFrameRequester(itowns.MAIN_LOOP_EVENTS.BEFORE_RENDER, scaler);

/*
            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://wxs.ign.fr/vboe9ia0y4tnpi7pxabn4dbj/geoportail/wfs?',//3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                version: '3.0.0',
                typeName: 'BDTOPO_V3:batiment', //'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                projection: 'EPSG:3857',//'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json',
                zoom: { min: 15, max: 15 },
              
            });
            */
           
            var wfsBuildingSource = new itowns.WFSSource({
                url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                version: '2.0.0',
                typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                projection: 'EPSG:4326',
                ipr: 'IGN',
                format: 'application/json',
                zoom: { min: 15, max: 15 },
                extent: {
                    west: -10,
                    east: 15.18,
                    south: 40.437,
                    north: 55,
                },
            });


            var wfsBuildingLayer = new itowns.GeometryLayer('WFS Building', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    color: colorBuildings,
                    batchId: function (property, featureId) { return featureId; },
                    altitude: altitudeBuildings,
                    extrude: extrudeBuildings }),
                onMeshCreated: function scaleZ(mesh) {
                    mesh.scale.z = 0.01;
                    meshes.push(mesh);
                    meshesForeverever.push(mesh);
                },
                filter: acceptFeature,
                overrideAltitudeInToZero: true,
                source: wfsBuildingSource
            });
            view.addLayer(wfsBuildingLayer);

            
            function colorLine(properties) {
                if (properties) {
                    rgb = properties.couleur.split(' ');
                    return color.setRGB(rgb[0] / 255, rgb[1] / 255, rgb[2] / 255);
                }
                return color.setRGB(1, 1, 1);
            }


            function setMaterialLineWidth(result) {
                console.log(result);
                result.traverse(function _setLineWidth(mesh) {
                    if (mesh.material) {
                        mesh.material.linewidth = 5;
                    }
                });
            }
            

            // Creates a camera using the metadata (extrinseque, intraseque and image url file)
            function createCamFromMetaData(posM, properties){

                    // Let's download the image
                    console.log("createCamFromMetaData: ", posM, properties);
                    var prop = properties; // m.feature.geometry[i].properties;
                    var imgName = prop.name; //console.log(prop);
                    var epsgquaternion = prop.epsgquaternion;
                    var source = prop.source; //console.log(imgName, epsgquaternion);
                    
                    // We check if already image displayed we don't treat it
                    if(arrLoadedCameraNames.includes(imgName)) return 0;

                    arrLoadedCameraNames.push(imgName);

                    //https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/2324-0191/IGNF_PVA_1-0__1947-04-10__C2324-0191_1947_CDP2368_0002.jp2&LYR=20&WID=200&CVT=JPEG
                    // Dessous: url fonctionnant pour les PVA IGN en jp2 servies par le Geoportail
                    // var url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                    var url = "../data/" + imgName;  // Default url (imported image from user for registration)
                    //  if(imgName.includes("IGNF_PVA"))
                    //     url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';

                    // We construct the url using the source table
                    // imageSourcesInfoDico is already constructed using the source table
                    if(source != null){ 
                        var propSource = imageSourcesInfoDico['sources.' + source];   console.log("poooooop", propSource);
                        if(propSource.iip != null)  // ex iip: "https://wxs.ign.fr/{key}/iipsrv.fcgi?FIF=DEMAT.PVA/{rlt}_{image}.jp2"
                            url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                            else if(propSource.highres != null)
                                url = propSource.highres.replace('{name}', imgName);//replace(/{name}/gi, )
                                else if(propSource.url != null) 
                                    url = propSource.url + imgName;
                                    else
                                        url = "../data/" + imgName;
                    }
                                        
                    // We check if image was inserted in database with extension ( avoid .jpg.jpg for example)
                    url = url.replace(".jpg.jpg", ".jpg");

                    // We now also add the image to the thumnails table (display them in 2d)
                    handleThumbnails("",{jpeg:url}, true); 

                    //url = "IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826_xs.jpg";  // temp for test
                    console.log(url);
                    // Temp to test with cropped image (Giordano)
                    //  if(url.includes("843"))
                     //   url ="http://134.158.74.36/alegoria/data/OIS-Reech_IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0843.jpg";

                    // We don't have a jp2 to jpg server (iip) yet so for the test we converted one image
                    // IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826
                    //var pvaTexture = new itowns.THREE.TextureLoader().load('IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826.jpg');

                    // We then create a photogrammetric camera using the PVA properties
                    // Intrinsec properties
                    var focal =  [prop.fx, prop.fy];
                    var size = [prop.sx, prop.sy];
                    //[ 9100, 9500 ]; //prop.px * 2, prop.py * 2];
                    var point = [ prop.px, prop.py ];
                    var disto = [ { type: "ModRad", C: new THREE.Vector2(prop.cx, prop.cy), R: new THREE.Vector4(prop.c3, prop.c5, prop.c7, prop.cm), project: RadialDistortion.project } ];
                    var imageMatrix = new THREE.Matrix4();
                    if(prop.m00 != undefined){  // If there are some Crop Infos, we set the image matrix (not identity)
                        imageMatrix.elements[0]  = prop.m00;
                        imageMatrix.elements[1]  = prop.m01;
                        imageMatrix.elements[4]  = prop.m10;
                        imageMatrix.elements[5]  = prop.m11;
                        imageMatrix.elements[12] = prop.m20;
                        imageMatrix.elements[13] = prop.m21;
                    }
                    var cameraP = new PhotogrammetricCamera(focal, size, point, 0, disto, undefined, undefined, undefined, imageMatrix );//, size, point, 0, [], 10, 10000); //, skew, distos, near, far);
                    // We inject the name of the image in the camera attributes
                    cameraP.name = url;
                    cameraP.originalName = imgName;
                    cameraP.propAdded = prop; // Dirty and naughty: we add all info we got to the photogrammetric camera object

                    // Extrinsec
                    var quaternion = new THREE.Quaternion(prop.qx, prop.qy, prop.qz, prop.qw); // console.log(m.feature.vertices.slice(i * 3, i * 3 + 3));
                    var pos = posM; // new THREE.Vector3().fromArray(m.feature.vertices.slice(i * 3, i * 3 + 3)); // console.log(pos); console.log(view.camera.camera3D.position); 
                    cameraP.position.copy(pos);

                    // Here we need to check the coordinate system of the received camera
                    // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                    if(epsgquaternion != undefined && epsgquaternion != 4978){  // projectionCode 
                        var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                        var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:' + epsgquaternion, "EPSG:4978")(coords);
                        quaternion.premultiply(quat_crs2crs);
                    }

                    
                    // Here we need to check the coordinate system of the received camera
                    // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                    if(epsgquaternion == undefined){  // projectionCode 
                        var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                        var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:2154' /*+ projectionCode*/, "EPSG:4978")(coords);
                        quaternion.premultiply(quat_crs2crs);
                        //quaternion.multiply(new THREE.Quaternion(1,0,0,0));
                    }

                    cameraP.quaternion.copy(quaternion);

                    if(url.includes("843")) {console.log("CAM 843: cameraP: ",cameraP, "prop: ", prop);
                        url = "OIS-Reech_IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0843FromMathieu.jpg";
                        cameraP.name = url;
                    }

                    createCameraHelper(cameraP);
                    handleOrientation(cameraP);   // Goes to that new created camera
            }

            
            // We don't have a jp2 to jpg server (iip) yet so for the test we converted one image
            // IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826
            var pvaTexture = new itowns.THREE.TextureLoader().load('IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826.jpg');

            // Handles PVA representation when received from WFS
            // Load image and project it on the ground using the image properties
            function workWithMesh(m, projectionCode){
                
                //console.log(m);
                m.material.size = 25;
                for (var i = 0; i < m.feature.geometry.length; ++i){
                    // Let's download the image
                    console.log(m.feature.geometry[i].properties.name);
                    var prop = m.feature.geometry[i].properties;
                    var imgName = prop.name; //console.log(prop);
                    var epsgquaternion = prop.epsgquaternion;
                    var source = prop.source; //console.log(imgName, epsgquaternion);
                    
                    // We check if already image displayed we don't treat it
                    if(arrLoadedCameraNames.includes(imgName)) return 0;

                    arrLoadedCameraNames.push(imgName);

                    //https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/2324-0191/IGNF_PVA_1-0__1947-04-10__C2324-0191_1947_CDP2368_0002.jp2&LYR=20&WID=200&CVT=JPEG
                    // Dessous: url fonctionnant pour les PVA IGN en jp2 servies par le Geoportail
                    // var url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                    var url = "../data/" + imgName;  // Default url (imported image from user for registration)
                    //  if(imgName.includes("IGNF_PVA"))
                    //     url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';

                    // We construct the url using the source table
                    // imageSourcesInfoDico is already constructed using the source table
                    if(source != null){ 
                        var propSource = imageSourcesInfoDico['sources.' + source];   console.log("poooooop", propSource);
                        if(propSource.iip != null)  // ex iip: "https://wxs.ign.fr/{key}/iipsrv.fcgi?FIF=DEMAT.PVA/{rlt}_{image}.jp2"
                            url = 'https://wxs.ign.fr/02eikbvn4qqd6y1g5iiiq8fi/iipsrv.fcgi?FIF=DEMAT.PVA/' + imgName + '.jp2' + '&WID=' + lowResValue + '&CVT=JPEG';
                            else if(propSource.highres != null)
                                url = propSource.highres.replace('{name}', imgName);//replace(/{name}/gi, )
                                else if(propSource.url != null) 
                                    url = propSource.url + imgName;
                                    else
                                        url = "../data/" + imgName;
                    }
                    
                    
                    // We check if image was inserted in database with extension ( avoid .jpg.jpg for example)
                    url = url.replace(".jpg.jpg", ".jpg");

                    // We now also add the image to the thumnails table (display them in 2d)
                    handleThumbnails("",{jpeg:url}, true); 

                    //url = "IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826_xs.jpg";  // temp for test
                    console.log(url);
                    // Temp to test with cropped image (Giordano)
                    //  if(url.includes("843"))
                     //   url ="http://134.158.74.36/alegoria/data/OIS-Reech_IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0843.jpg";

                    // We don't have a jp2 to jpg server (iip) yet so for the test we converted one image
                    // IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826
                    //var pvaTexture = new itowns.THREE.TextureLoader().load('IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0826.jpg');

                    // We then create a photogrammetric camera using the PVA properties
                    // Intrinsec properties
                    var focal =  [prop.fx, prop.fy];
                    var size = [prop.sx, prop.sy];
                    //[ 9100, 9500 ]; //prop.px * 2, prop.py * 2];
                    var point = [ prop.px, prop.py ];
                    var disto = [ { type: "ModRad", C: new THREE.Vector2(prop.cx, prop.cy), R: new THREE.Vector4(prop.c3, prop.c5, prop.c7, prop.cm), project: RadialDistortion.project } ];
                    var imageMatrix = new THREE.Matrix4();
                    if(prop.m00 != undefined){  // If there are some Crop Infos, we set the image matrix (not identity)
                        imageMatrix.elements[0]  = prop.m00;
                        imageMatrix.elements[1]  = prop.m01;
                        imageMatrix.elements[4]  = prop.m10;
                        imageMatrix.elements[5]  = prop.m11;
                        imageMatrix.elements[12] = prop.m20;
                        imageMatrix.elements[13] = prop.m21;
                    }
                    var cameraP = new PhotogrammetricCamera(focal, size, point, 0, disto, undefined, undefined, undefined, imageMatrix );//, size, point, 0, [], 10, 10000); //, skew, distos, near, far);
                    // We inject the name of the image in the camera attributes
                    cameraP.name = url;
                    cameraP.originalName = imgName;
                    cameraP.propAdded = prop; // Dirty and naughty: we add all info we got to the photogrammetric camera object

                    // Extrinsec
                    var quaternion = new THREE.Quaternion(prop.qx, prop.qy, prop.qz, prop.qw); // console.log(m.feature.vertices.slice(i * 3, i * 3 + 3));
                    var pos = new THREE.Vector3().fromArray(m.feature.vertices.slice(i * 3, i * 3 + 3)); // console.log(pos); console.log(view.camera.camera3D.position); 
                    cameraP.position.copy(pos);

                    // Here we need to check the coordinate system of the received camera
                    // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                    if(epsgquaternion != undefined && epsgquaternion != 4978){  // projectionCode 
                        var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                        var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:' + epsgquaternion, "EPSG:4978")(coords);
                        quaternion.premultiply(quat_crs2crs);
                    }

                    
                    // Here we need to check the coordinate system of the received camera
                    // If already EPSG:4978, nothing to do. If other, we need to compute the new orientation in our scene system (4978)
                    if(epsgquaternion == undefined){  // projectionCode 
                        var coords = new itowns.Coordinates('EPSG:4978', pos.x, pos.y, pos.z);
                        var quat_crs2crs = itowns.OrientationUtils.quaternionFromCRSToCRS('EPSG:2154' /*+ projectionCode*/, "EPSG:4978")(coords);
                        quaternion.premultiply(quat_crs2crs);
                        //quaternion.multiply(new THREE.Quaternion(1,0,0,0));
                    }

                    cameraP.quaternion.copy(quaternion);

                    if(url.includes("843")) {console.log("CAM 843: cameraP: ",cameraP, "prop: ", prop);
                        url = "OIS-Reech_IGNF_PVA_1-0__1966__C3544-0311_1966_CDP5335_0843FromMathieu.jpg";
                        cameraP.name = url;
                    }

                    createCameraHelper(cameraP);
                    // m.add(sceneAllCams);
                }
                //m.add(sceneAllCams); 
                /*
                handleOrientation(cameraP);
                textureMaterial.map = pvaTexture;   // ! Dirty ! Asynchronous with camHelper creation...
                textureMaterial.transparent = true;
                */
            }

            function playWithProperties(properties){
                console.log(properties);
            }



            
            // Access archives_nationales WFS
            var wfsGeoserverSourceAN = new itowns.WFSSource({
                url: 'http://134.158.74.36:8080/geoserver/alegoria/ows?',
                protocol:'wfs',
                version: '2.0.0',
                typeName: 'archives_nationales', // 'alegoria%3Ananterre_1960_2314_1701_full', //'alegoria%3Ananterre_1960_2314_1701_full',//'alegoria%3Aforcalquier',//'alegoria%3Afrejus',
                projection: 'EPSG:4326',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 14, max: 14 },
                networkOptions: {crossOrigin: ''}
            });

            var wfsGeoserverLayerAN = new itowns.GeometryLayer('WFS Geoserver Archives Nationales', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    playWithProperties: playWithProperties,
                    color: new itowns.THREE.Color() }),
                overrideAltitudeInToZero: true,
                onMeshCreated: function(mesh){showImageInfo(mesh,'EPSG:4326');},
                source: wfsGeoserverSourceAN
            });
            view.addLayer(wfsGeoserverLayerAN);


            
            // What do we do with archives images (not registered a priori)
            function showImageInfo(m, proj){
                for (var i = 0; i < m.feature.geometry.length; ++i){

                    //if(arrImagesArchives.imgName return 0;
                    
                    var prop = m.feature.geometry[i].properties;
                    if(imagesArchivesDico[prop.jpeg] == undefined){
                        imagesArchivesDico[prop.jpeg] = prop;
                        //console.log(m.feature.geometry[i], prop);
                        var pos = new itowns.Coordinates('EPSG:4326',  prop.longitude , prop.latitude, 250).as('EPSG:4978');
                        var geometry = new itowns.THREE.SphereGeometry( 80, 4, 4 );
                        var material = new itowns.THREE.MeshBasicMaterial( {color:new itowns.THREE.Color(0XFF0000), transparent:true, opacity:0.1} );
                        var sphere = new itowns.THREE.Mesh( geometry, material );
                        sphere.position.set(pos.x, pos.y, pos.z); // console.log(sphere.position);
                        sphere.updateMatrixWorld();
                        view.scene.add( sphere );

                        handleThumbnails("http://134.158.74.36/images/archives_nationales/", prop, false);//.jpeg);
                    }
                }
                // console.log(imagesArchivesDico);
                view.notifyChange();
                // m.material.size = 250;
                // m.material.color = new THREE.Color('red');
                // console.log(m);
                var keys = Object.keys( imagesArchivesDico );
                var imgOBJ = keys[0]; 
            }


            function handleThumbnails(urlSource, prop, georeferenced){

                var img = new Image(thumbnailWidth, thumbnailHeight); //document.createElement('img'); 
                img.src = urlSource  + prop.jpeg; // "http://134.158.74.36/images/archives_nationales/FRAN_0207_0155_L.jpg";
                // img.nameAlegoria = img.src;
                img.alegoriaProp = prop;
                img.georeferenced = georeferenced;
                if(georeferenced){
                    img.style.cssText = " border: 4px solid #2FA1D6"; 
                }
                //console.log(img.src);
                var table = document.getElementById('myTable');
                var nbRows = table.rows.length;
                let currentRow;
                if(nbRows < 1) // Happens only once
                    currentRow = table.insertRow(-1);
                else
                    currentRow = table.rows[0];

                img.onload = function() {
                    var realWidth = img.naturalWidth;
                    var realHeight = img.naturalHeight;
                    img.width = realWidth / (realHeight / 168);
                    var col = currentRow.insertCell(0);
                    col.appendChild(img); 
                    img.addEventListener("click", displayImage);
                    img.addEventListener("mouseenter", displayMetaData);
                };
                
            }


            // This function displays the selected image (thumbnail) in bigger to make the resection 
            // OR if already registered direclty in front of CameraIMAGE
            function displayImage(evt){

                evt.cancelBubble = true;
                var currentImgProp = evt.target.alegoriaProp;
                //console.log("click image", currentImgProp);
                // console.log(sceneAllCams.children);
               // console.log("arrrrrrrrrrrrrrrrrrr", arrLoadedCameraNames, currentImgProp.jpeg);
                // We first check if image is registered or not using a WFS request (TOTO)
                // temporarly for a test, we just check the already loaded CameraImage 
                var imgName = currentImgProp.jpeg.substring((currentImgProp.jpeg.lastIndexOf('/') + 1));
                
                // If iip url we recover the original imgName to look for it in camera names array
                if (currentImgProp.jpeg.lastIndexOf('&CVT') >=0 ){
                    var start =  currentImgProp.jpeg.lastIndexOf('.PVA');
                    var end = currentImgProp.jpeg.lastIndexOf('.jp2');
                    imgName = currentImgProp.jpeg.substring(start + 5, end);
                }

                if(arrLoadedCameraNames.includes(imgName)){   //currentImgProp.jpeg

                    //console.log('Image ' + currentImgProp.jpeg + 'already georeferenced');
                    var sceneCAMS = sceneAllCams.children;
                    var camImg;
                    var a = 0;
                    var found = false;
                    while(a < sceneCAMS.length && !found){
                        if(sceneCAMS[a].name.indexOf(currentImgProp.jpeg) >= 0 ){
                            camImg = sceneCAMS[a];
                            found = true;
                        }                    
                        a++;
                    }
                    handleOrientation(camImg);
                }

                else{   // We show the image in order for the user to register it
 
                    currentDATADirectory = "../../images/archives_nationales";
                    currentSource = 5;
                    document.getElementById('img').src =  "http://134.158.74.36/images/archives_nationales/" + currentImgProp.jpeg;

                    // Then we create (initialize) the 4 xml files needed. Ground points, 2D image point, camera calibration and the micmac chantier descriptor
                    setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                        arrayImages.unshift(  {image: currentImgProp.jpeg, distance: 100, opacity: 1, plane:null} );
                        initXML2D();
                        initXML3D();
                        createCalib(); // We create a calibration file knowing just the image size 
                        createMicmacChantierDescripteur(); // We create the micmac chantier descriptor
                        }, 1000);
                    }
            }


            function displayMetaData(evt){
                var currentImgProp = evt.target.alegoriaProp;
                var divMeta = document.getElementById('metaData');
               // if(currentImgProp.description == null) currentImgProp.description = "";
               // if(currentImgProp.city == null) currentImgProp.city = "";

                var desc = currentImgProp.number + " | " + currentImgProp.cote + " | " + currentImgProp.mission + " | " + 
                currentImgProp.dpt_new + " | " + currentImgProp.support + " | " + currentImgProp.producer + " | " +
                currentImgProp.description + " | " + currentImgProp.city + " | " + currentImgProp.jpeg + " | " +
                currentImgProp.latitude + " | " + currentImgProp.longitude;
                const regex = /\| null/gi;
                divMeta.innerHTML = desc.replace(regex, "");
                //JSON.stringify(currentImgProp);
            }


            // Access to our Geoservers (On ISC) to get registered cameras  (ex alegoriaMerge2)
            var wfsGeoserverSource = new itowns.WFSSource({
                url: 'http://134.158.74.36:8080/geoserver/alegoria/ows?',
                protocol:'wfs',
                version: '2.0.0',
                typeName: wfsInURL || defaultWFSCamera, // 'alegoria%3Ananterre_1960_2314_1701_full', //'alegoria%3Ananterre_1960_2314_1701_full',//'alegoria%3Aforcalquier',//'alegoria%3Afrejus',
                projection: 'EPSG:4978',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 7, max: 7 },
                networkOptions: {crossOrigin: ''}
            });

            
            var wfsGeoserverLayer = new itowns.GeometryLayer('WFS Geoserver', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    //playWithProperties: playWithProperties,
                    color: new itowns.THREE.Color() }),
                onMeshCreated: function(mesh){workWithMesh(mesh,'EPSG:4978');},//workWithMesh(mesh),
                source: wfsGeoserverSource
            });
            view.addLayer(wfsGeoserverLayer);



            // Test all France Mathieu DB
            // Access to our Geoservers (On ISC) to get registered cameras  (ex alegoriaMerge2)
            var wfsGeoserverSourceTA = new itowns.WFSSource({
                url: 'http://134.158.74.36:8080/geoserver/alegoria/ows?',
                protocol:'wfs',
                version: '2.0.0',
                typeName: 'alegoria_ta2', //wfsInURL || defaultWFSCamera, // 'alegoria%3Ananterre_1960_2314_1701_full', //'alegoria%3Ananterre_1960_2314_1701_full',//'alegoria%3Aforcalquier',//'alegoria%3Afrejus',
                projection: 'EPSG:2154',
                fetcher: itowns.Fetcher.json,
                parser: itowns.GeoJsonParser.parse,
                ipr: 'Alegoria',
                format: 'json',
                zoom: { min: 16, max: 16 },
                networkOptions: {crossOrigin: ''}
            });

            
            var wfsGeoserverLayerTA = new itowns.GeometryLayer('WFS Geoserver TA', new itowns.THREE.Group(), {
                update: itowns.FeatureProcessing.update,
                convert: itowns.Feature2Mesh.convert({
                    //playWithProperties: playWithProperties,
                    color: new itowns.THREE.Color() }),
                onMeshCreated: function(mesh){workWithMesh(mesh,'EPSG:2154');},//workWithMesh(mesh),
                source: wfsGeoserverSourceTA
            });
        //    view.addLayer(wfsGeoserverLayerTA);



            // Function to load at initialization 
            function loadImageSources(){

                fetch('http://134.158.74.36:8080/geoserver/alegoria/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=alegoria%3Asources&outputFormat=application%2Fjson').then(
                        function(response) {
                            if (response.status !== 200) {
                                console.log('Looks like there was a problem. Status Code: ' + response.status);
                                return;
                            }
                            response.json().then(function(data) {
                                 imageSourcesInfo = data;
                                // We construct a dictionnary to improve access speed for later on
                                for( var i= 0; i< imageSourcesInfo.features.length; ++i ){
                                    var feat = imageSourcesInfo.features[i];
                                    imageSourcesInfoDico[feat.id] = feat.properties;
                                }
                                 // console.log(imageSourcesInfo, imageSourcesInfoDico);
                            });
                        }
                    ).catch(function(err) {
                        console.log('Fetch Error :-S', err);
                    });

            }
                     

            // Listen for globe full initialisation event
            view.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, function () {
                // eslint-disable-next-line no-console
                console.info('Globe initialized');
                //loadImageSources();
                //updateScaleWidget();
                // get 3D coordinates on mouse click
                window.addEventListener('mousedown', pickPosition, false);
                function pickPosition(event) {
                  
                    if(event.altKey){
                        // increment point number
                        ptname += 1;
                        document.getElementById('countPoints').innerHTML = "Points registered: " + ptname;
                        var pickBuilding = pickingBuildings(event);

                        if(pickBuilding.z == 0){
                            // get 3D coordinates on ground
                            geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(event.pageX,event.pageY));
                            //console.log(view.controls.pickGeoPosition(view.eventToViewCoords(event.altKey)));
                            // convert coordinates to geographic system
                            let converted = geoposition.as('EPSG:4978'); console.log(converted);
                            //coordinates = converted._values;
                            x = converted.x;
                            y = converted.y;
                            z = converted.z;
                        }
                        else{
                            x = pickBuilding.x, y = pickBuilding.y, z = pickBuilding.z;
                        }
                            
                        show3DPicking(x,y,z, ptname);
                        // export 3D coordinates to an xml file
                        export3Dcoord(ptname,x,y,z);
                        console.log("Nb of points picked: ", ptname);

                        // Launch computation after at least 3 points
                        if(ptname >= 4){
                            computeResection({}, document.getElementById('img').src.split('/').pop(), false);
                        }
                    }
                }

                // load3DModel();

                // If the user specified an imgName in the url, we request the WFS to go to it
                if(imName !== null){
                    console.log("accessing image specified in URL: ", imName);
                    var url = "http://134.158.74.36:8080/geoserver/alegoria/ows?SERVICE=WFS&REQUEST=GetFeature&typeName=alegoriaMerge2&VERSION=2.0.0&outputFormat=json&CQL_FILTER=name=%27" + imName + "%27";
                    fetch(url)
                    .then((response) => {
                        return response.json();
                    })
                    .then((myJson) => {
                        console.log(myJson);
                        var feat = myJson.features[0];
                        createCamFromMetaData(new THREE.Vector3(feat.geometry.coordinates[0],feat.geometry.coordinates[1],feat.geometry.coordinates[2]) ,feat.properties);
                        if(arrLoadedCameraNames.includes(imName)){  
                            var sceneCAMS = sceneAllCams.children;
                            var camImg;
                            var a = 0;
                            var found = false;
                            while(a < sceneCAMS.length && !found){
                                if(sceneCAMS[a].name.indexOf(imName) >= 0 ){
                                    camImg = sceneCAMS[a];
                                    found = true;
                                }                    
                                a++;
                            }
                            handleOrientation(camImg);
                            }
                    });

                }

            });


            // Picking on buildings
            function pickingBuildings(event) {
                var p3D = new itowns.THREE.Vector3();
                if(view.controls.isPaused) {
                    var intersects = view.pickObjectsAt(event, 3, 'WFS Building');
                    if (intersects.length) {
                        //console.log(intersects[0].point);
                        p3D = intersects[0].point;
                    }
                }
                return p3D;
            }


            // ------ Upload Part --------------------------------------------------------------------------
            const url = 'process.php';
            const form = document.querySelector('form');

            form.addEventListener('submit', e => {
                currentDATADirectory = "../data";
                currentSource = 10; // default alex source
                e.preventDefault();

                const files = document.querySelector('[type=file]').files;
                const formData = new FormData();

                for (let i = 0; i < files.length; i++) {
                    let file = files[i];

                    formData.append('files[]', file);
                }
                console.log(form, formData, files, files[0].name);
                fetch(url, {
                    method: 'POST',
                    body: formData
                }).then(response => {
                    console.log(response);
                    document.getElementById("img").src = "../data/" + files[0].name;  // Get displayed image name
                    
                    
                    // Then we create (initialize) the 4 xml files needed. Ground points, 2D image point, camera calibration and the micmac chantier descriptor
                    setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                        arrayImages.unshift(  {image: files[0].name, distance: 100, opacity: 1, plane:null} );
                        initXML2D();
                        initXML3D();
                        createCalib(); // We create a calibration file knowing just the image size 
                        createMicmacChantierDescripteur(); // We create the micmac chantier descriptor
                    }, 1000);
                }); 
            });



/*
            view.controls.addEventListener(itowns.CONTROL_EVENTS.RANGE_CHANGED, () => {
                updateScaleWidget();
            });
*/
            // Draw a sphere to show where the 3D picking has been done
            function show3DPicking(x,y,z, iteration){

                var geometry = new itowns.THREE.SphereGeometry( 8, 16, 16 );
                var col = new itowns.THREE.Color(0XFFFF00);
                var material = new itowns.THREE.MeshBasicMaterial( {color: col.lerpHSL(new itowns.THREE.Color(0XFF0000), (iteration % 8) / 7), transparent:true, opacity:0.8} );
                var sphere = new itowns.THREE.Mesh( geometry, material );
                sphere.position.set(x,y,z); //console.log(sphere.position);
                sphere.updateMatrixWorld();
                view.scene.add( sphere );
                view.notifyChange();
            }


            function launchMicMac(event, imgName){
    
                var xmlhttp;
                if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                } else { // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        console.log(this.responseText);
                        /*
                        var output_array = JSON.parse(this.responseText);
                        var output = output_array['output'];
                        var returned_value = output_array['status'];
                        console.log(output);
                        if(returned_value==0){
                            alert("MicMac calculations are done!");
                            window.location.href = 'oriented_images.html';
                            
                        }else{
                            alert("MicMac failed to calculate orientation, for more info press on F12");
                        }
                        */
                        window.open('globe.html?imgname=' + imgName);/*oriented_images*/
                    }
                };

                xmlhttp.open("GET", "launchMicMac.php" +"?"+ "imagename=" + imgName + "&dir=" + currentDATADirectory, true);
                xmlhttp.send();
            }
            

            // Launch micmac computation
            function computeResection(event, imgName, show){
                console.log("Computing resection of image: ", imgName);
                currentImageName = imgName;
                var xmlhttp;
                if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
                    xmlhttp = new XMLHttpRequest();
                } else { // code for IE6, IE5
                    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
                }

                xmlhttp.onreadystatechange = function() {
                    if (this.readyState == 4 && this.status == 200) {
                        console.log(this.responseText);
                        // arrayImages.unshift(  {image: imgName, distance: 100, opacity: 1, plane:null} );
                        if(show) showResection();
                    }
                };
                xmlhttp.open("GET", "launchMicMac.php" +"?"+ "imagename=" + imgName + "&dir=" + currentDATADirectory, true);
                xmlhttp.send();
            }


                        
            // launch full pipeline
            function computeResectionFullAuto(){
                saveAsImageToServer();
            }
                            

            // Show oriented image using micmac aspro xml
            function showResection(){
                
                // fetch orientation file
                var source = new FetchSource('../outputs/test/');
                // parse micmac orientation
                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                    .then(data => MicmacOrientationParser.parse(data, source))
                    .then(handleOrientation);
            }

            
            // Show oriented image using micmac aspro xml
            function previewResection(){
                
                // fetch orientation file
                var source = new FetchSource('../outputs/test/');
                // parse micmac orientation
                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                    .then(data => MicmacOrientationParser.parse(data, source))
                    .then(handleOrientation);
            }



            /******************* Rendering functions **********************************************/
            
            
            /* Orientation loading */
            function cameraHelper(camera, mat) {
                var wireMaterial = new THREE.MeshBasicMaterial( {color: Math.random() * 0XFFFFFF, wireframe: true} );
                // create the group (looking at intrinsics only) that should be added to the camera frame.
                var group = new THREE.Group();
                // place a frustum
                {
                    m = new THREE.Matrix4().getInverse(camera.projectionMatrix);
                    var geometry = new THREE.BufferGeometry();
                    var vertices = new Float32Array(15);
                    // get the 4 corners on the near plane (neglecting distortion)
                    new THREE.Vector3( -1, -1, -1 ).applyMatrix4(m).toArray(vertices,  3);
                    new THREE.Vector3( -1,  1, -1 ).applyMatrix4(m).toArray(vertices,  6);
                    new THREE.Vector3(  1,  1, -1 ).applyMatrix4(m).toArray(vertices,  9);
                    new THREE.Vector3(  1, -1, -1 ).applyMatrix4(m).toArray(vertices, 12);
                    var indices = [ 0, 1, 2,  0, 2, 3,  0, 3, 4,  0, 4, 1,  1, 3, 2,  1, 4, 3 ];
                    geometry.setIndex( indices );
                    geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
                    geometry.addGroup(0, 12, 0);
                    geometry.addGroup(12, 6, 1);
                    // viewMaterials[camera.name] = new OrientedImageMaterial(viewMaterialOptions);
                    // viewMaterials[camera.name].map = textures[camera.name] || uvTexture;
                    // mat.map = uvTexture; 
                    var mesh = new THREE.Mesh( geometry, [wireMaterial, mat] );
                    mesh.scale.set(200, 200, 200);
                    group.add(mesh);
                }
                // place a sphere at the camera center
                {
                    var geometry = new THREE.SphereBufferGeometry(2, 8, 8 );
                    var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                   // group.add(new THREE.Mesh( geometry, material ));
                }
                return group;
            };


            function setMaterial(material, camera) {
                //material.map =  uvTexture; //textures[camera.name] || uvTexture;
                camera.getWorldPosition(material.uvwPosition);
                const m = new THREE.Matrix4().copy(camera.matrixWorldInverse);
                m.setPosition(0,0,0);
                material.uvwPreTransform.copy(camera.preProjectionMatrix).multiply(m);
                material.uvwPostTransform.copy(camera.postProjectionMatrix);
                
                if (camera.distos && camera.distos.length == 1 && camera.distos[0].type === 'ModRad') {
                    material.uvDistortion = camera.distos[0];
                } else {
                    material.uvDistortion = { C: new THREE.Vector2(), R: new THREE.Vector4() };
                    material.uvDistortion.R.w = Infinity;
                }
            }


            // Function to export the photogrammetric camera to the Database through WFS
            function saveCamToWFS(){
                exportToWFS(camera, "alegoriaMerge2", currentSource);  // Previously successfully tested with table alegoria5
            }

            // Uncomment playvideo
            function playVideo(){

                var videoName =  "../data/pontneufCropped.mp4"; //pictureInfos.image;
                var x = document.createElement("VIDEO");
                x.setAttribute("id", "video");
                if (x.canPlayType("video/mp4")) {
                    x.setAttribute("src",videoName);
                } 
                x.setAttribute("width", "840");
                x.setAttribute("height", "700");
                x.setAttribute("controls", "controls");
                document.body.appendChild(x);
                var video = document.getElementById( 'video' );
     //video.play();
                var texture = new THREE.VideoTexture( video );  console.log(video, texture);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.format = THREE.RGBFormat;
                textureMaterial.map = texture;
                updateRenderingAlwaysForVideo();

                // Faisceaux
                showFaisceaux();
            }

            
            function updateRenderingAlwaysForVideo(){

                view.notifyChange();
                requestAnimationFrame( updateRenderingAlwaysForVideo );

             };


            const uvTexture = new itowns.THREE.TextureLoader().load('../data/uv.jpg');
            

            // function to handle micmac orientation file
            function handleOrientation(cam) {
                 console.log("Handle Orientation of cam: ",cam);
                // Ugly way, if currently shown and refine orientation we remove oriented cam and recreate all...
                if(currentOrientationWorkedImage == currentImageName){
                    view.scene.remove(globalCurrentCamOriented);
                }

                currentOrientationWorkedImage = currentImageName;
                //view.camera._preSSE = 12000;  // Weird but needed to keep good tile resolution
                arrDisplayedImages.push(cam);

                // Already set in case of DB WFS. We can set here the High Resolution image (TODO)
                if(cam.name === ""){  // Old school XML
                    setMaterial(textureMaterial, cam);
                    camHelper = cameraHelper(cam, textureMaterial);
                    var scale = currentDistance / 100;
                    camHelper.scale.set(scale,scale,scale);
                    cam.add(camHelper);
                    cam.updateMatrixWorld();
                    globalCurrentCamOriented = cam;
                    view.scene.add(globalCurrentCamOriented);  
                    // camera set from micmac orientation file
                    camera = cam;
                }else{   // DB WFS
                    globalCurrentCamOriented = cam;
                    camera = cam;
                }

                var pictureInfos = arrayImages[currentIndiceNav];

                // Dirty mod to handle previous version with the new DB WFS one
                if(cam.name === ""){ // Old School XMl

                    console.log("cam.name  null", cam);
                    if(pictureInfos.plane == null){
                        plane = setupPictureFromCamera(camera, currentDATADirectory + pictureInfos.image, pictureInfos.opacity, pictureInfos.distance); // plane is added to the photogra camara (so the scene)
                        pictureInfos.plane = plane; console.log("picturesinfos.planeee: ", plane);
                    }else{
                        plane = pictureInfos.plane;
                    }
                    plane.visible = false;
                    cam.name = cam.originalName = pictureInfos.image;
                    textureMaterial.map = new itowns.THREE.TextureLoader().load(currentDATADirectory + "/" + pictureInfos.image);
                }else{  // WFS Mode
                    // We update the image with a bigger resolution
                    console.log("cam.namecam.namecam.namecam.name: ",cam.name);
                    cam.name =  cam.name.replace("WID=" + lowResValue, "WID=" + highResValue);
                    textureMaterial.map = new itowns.THREE.TextureLoader().load(cam.name);
                    console.log("textureMaterial.map ",textureMaterial.map);
                    /*
                    var textureMaterialP = new OrientedImageMaterial({
                        map: new itowns.THREE.TextureLoader().load(cam.name), // new itowns.THREE.TextureLoader().load('../data/uv.jpg'),
                        opacity:currentOpacity,
                        transparent:true,
                    });
            
                    setMaterial(textureMaterialP, cam);
                    */
                }
                
                textureMaterial.transparent = true;
                updateCamera();

                view.camera.camera3D.updateProjectionMatrix();

                // set GUI for oriented image
                if(!orientedMenu){
                    orientedImageGUI = setupPictureUI(menuGlobe, pictureInfos, plane, updatePlaneDistance, updatePlaneOpacity, updateZoom, view, 150, 1000);  
                    orientedMenu = true; 
                }
                
                view.notifyChange(view.camera.camera3D);
            }


            // Function that create cameraHelper with all the properties of the oriented image
            // Picking on it to associate camera scene
            function createCameraHelper(cam){
                // console.log(cam);
                // Concerning the texture, Ideally we initiate with a low res (thumbnail) and then
                // when the user chooses that camera it'll load HiRes. 
                // Low res should be found using camera name + "lowres".jpg for example or more dynamically 
                // using IIP Image jp2 multi res
                var textureMaterialP = new OrientedImageMaterial({
                    map: new itowns.THREE.TextureLoader().load(cam.name), // new itowns.THREE.TextureLoader().load('../data/uv.jpg'),
                    opacity:currentOpacity,
                    transparent:true,
                    side: THREE.DoubleSide
                });

                setMaterial(textureMaterialP, cam);
                var camHelper = cameraHelper(cam, textureMaterialP);
                var scale = currentDistance / 100;
                camHelper.scale.set(scale,scale,scale);
                cam.add(camHelper);
                cam.updateMatrixWorld();
                sceneAllCams.add(cam);
                // console.log(cam);
                // view.scene.add(cam);  
            }

/*
            // If no initial position passed in the URL we launch the first registered image
            if(! posInit && arrayImages.length > 0){
                // fetch orientation file
                var source = new FetchSource('../outputs/test/');
                // parse micmac orientation
                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                    .then(data => MicmacOrientationParser.parse(data, source))
                    .then(handleOrientation);
            }
*/


            function updatePlaneDistance(value) {

                currentDistance = value;
                var scale = value / 100;
                currentObjUnderMouse.scale.set(scale,scale,scale);
                view.notifyChange(view.camera.camera3D);
            }
           
            function updatePlaneOpacity(value) {
                currentOpacity = value;
                textureMaterial.transparent = true;
                if(plane) plane.material.opacity = value;
                textureMaterial.opacity = value;
                view.notifyChange(view.camera.camera3D);
            }

            function updateZoom(value) {
                
                view.camera.camera3D.zoom = value; 
                view.camera.camera3D.updateProjectionMatrix();
                view.notifyChange(view.camera.camera3D);

            //    console.log(view.camera);
            }

            // update camera and view
            function updateCamera() {
                setupViewCameraDecomposing(view, camera);
                //if (cameraHelper) cameraHelper.updateMatrixWorld(true);
                view.notifyChange(view.camera.camera3D);
            }

            function projectOnBuildings(){
                //console.log("projeccc", meshesForeverever);
                for(var m in meshesForeverever)
                    meshesForeverever[m].material = textureMaterial;      

                // Add background for Street Level 
                if(olayer){
                    var copyBackground = olayer.background.clone();
                    console.log(olayer);
                    copyBackground.material = textureMaterial; //new THREE.MeshBasicMaterial(); //textureMaterial;
                    copyBackground.position.addScalar(0.1);
                    copyBackground.updateMatrixWorld();
                    copyBackground.material.side = THREE.DoubleSide;
                    copyBackground.material.transparent = true;
                    copyBackground.material.opacity = 0.99;
                    console.log("copyyyy", copyBackground);
                    view.scene.add(copyBackground);
                    view.notifyChange();
            }

                 // set camera's layer to do not disturb the picking
                 //  model.traverse(function _(obj) { obj.material = textureMaterial;}) //console.log(obj);  /*obj.layers.set(colladaID); */ });

            }

            
            // eslint-disable-next-line no-unused-vars
            function menuNavigUI(menu, pictureInfos, subMenu) {

                var navImageGUI = subMenu; //menu.gui.addFolder('Navigation Image');
                var obj  = { next:function(){ nextImage() }};
                var obj2 = { projectOnBuildings:function(){projectOnBuildings()}};
                var obj3 = { resetPosition:function(){ resetPosition() }};
                var obj4 = { previewResection: function(){ previewResection() }};
                var obj5 = { fog: 0.};
                var obj6 = { near: nearProj};
                var obj7 = { far: farProj};
                var obj8 = { parallax: 0.};
                var obj9 = { activateStreetLevel: function(){ activateStreetLevel() }};
                var obj10 = { resectionAuto: function(){ computeResectionFullAuto() }};
                var obj11 = { saveRegistration: function(){ saveCamToWFS() /* playVideo(); */ }};
                var obj12 = { date: 1951};
                
                navImageGUI.add(obj,'next');
                navImageGUI.add(obj2,'projectOnBuildings');
                navImageGUI.add(obj3,'resetPosition');
                navImageGUI.add(obj4,'previewResection');
                navImageGUI.add(obj5,'fog', 0., 1.).onChange(function setFogValue(value){textureMaterial.uniforms.foggy.value = value; view.notifyChange();});
                navImageGUI.add(obj6,'near', 8., 250.).onChange(function setNearValue(value){textureMaterial.uniforms.near.value = value; nearProj = value; createDepthMap(); view.notifyChange();});
                navImageGUI.add(obj7,'far', 8., 250.).onChange(function setFarValue(value){textureMaterial.uniforms.far.value = value; farProj = value; createDepthMap() ; view.notifyChange();});
                navImageGUI.add(obj8,'parallax', 0., 1.).onChange(function setParallaxValue(value){textureMaterial.uniforms.parallax.value = value; view.notifyChange();});
                navImageGUI.add(obj9,'activateStreetLevel');
                navImageGUI.add(obj10,'resectionAuto');
                navImageGUI.add(obj11,'saveRegistration');
                navImageGUI.add(obj12,'date', 1940, 1980).onChange(function filterD(value){filterDates(value); view.notifyChange();});
                view.notifyChange(view.camera.camera3D);
            }

            // eslint-disable-next-line no-unused-vars
            function setupPictureUI(menu, pictureInfos, plane, updateDistanceCallback, updateOpacityCallback, updateFOVCallback, view, min, max) {
                var orientedImageGUI = menu.gui.addFolder('Oriented Image');

                orientedImageGUI.add(pictureInfos, 'distance', min, max).name('Distance').onChange(function distanceChanged(value) {
                    pictureInfos.distance = value;
                    updateDistanceCallback(value);
                    view.notifyChange();
                });

                orientedImageGUI.add(pictureInfos, 'opacity', 0, 1).name('Opacity').onChange(function opacityChanged(value) {
                    pictureInfos.opacity = value;
                    updateOpacityCallback(value);
                    view.notifyChange();
                });
                
                var pF = {zoom:1.};
                orientedImageGUI.add( pF, 'zoom', 0.01, 2.).name('Zoom').onChange(function fovChanged(value) {
                    //pictureInfos.opacity = value;
                    updateFOVCallback(value);
                    view.notifyChange();
                });

                var navMenu = menuNavigUI(menuGlobe, arrayImages, orientedImageGUI);
            }

            function nextImage(){
               // meshesForeverever = [];
                currentIndiceNav = (currentIndiceNav + 1) % arrayImages.length; 
                console.log('indice image: ', currentIndiceNav);

                source.open('Ori-Aspro/Orientation-' + arrayImages[currentIndiceNav].image + '.xml', 'text') // change orientation file each time you change the picture!
                .then(data => MicmacOrientationParser.parse(data, source))
                .then(handleOrientation);
                //view.notifyChange();
            }
            

            // Put scene camera back to original position (center of photocamera)
            function resetPosition(){
                updateCamera();
            }


            // Activate street level imagery
            function activateStreetLevel(){
                
                // create Immersive control
       /*         view.controls = new itowns.StreetControls(view, {
                    animationDuration: 50,
                });
        */
                // limit camera far, to increase performance
                view.camera.camera3D.near = 0.8;
         /*       view.camera.camera3D.far = 10000;
                view.camera.camera3D.near = 0.1;
                // open camera fov
                view.camera.camera3D.fov = 75;
                view.camera.camera3D.updateProjectionMatrix();
           */     // disable atmosphere
                view.getLayerById('atmosphere').visible = false;
                // Prepare oriented image source
                var orientedImageSource = new itowns.OrientedImageSource({  
                        url:  '20150812-150812_0421-{cameraId}-00001_0000{panoId}.jpg' // ! The images have been moved to ../data/streetLevelImages/  //'20150729-150729_0521-{cameraId}-00003_0000{panoId}.jpg' // 'Paris-140606_0713-{cameraId}-00001_0000{panoId}.jpg' // '20150729-150729_0521-{cameraId}-00005_0000{panoId}.jpg'// 'Paris2015-141106_0725-{cameraId}-00004_0000{panoId}.jpg' // Paris2015-141106_0725-00-00004_0000546 //'Paris-140606_0713-{cameraId}-00001_0000{panoId}.jpg' //  // 2 Zero to remove 'CalibV4-140407_0566-{cameraId}-00008_0000{panoId}.jpg' // 'CalibV4-140407_0566-{cameraId}-00006_0000{panoId}.jpg' // 'Paris2015-150123_0593-{cameraId}-00004_0000{panoId}.jpg'//'Paris-150630_0723-{cameraId}-00005_0000{panoId}.jpg'  // 'CalibV4-140407_0566-{cameraId}-00006_0000{panoId}.jpg' 
                    });

                // Url to a GEOJSON file describing feature points. It describre position and orientation of each panoramic.
                var orientationsUrl = 'panoramicsMetaDataParis.geojson';
                var calibrationUrl = 'https://raw.githubusercontent.com/iTowns/iTowns2-sample-data/master/immersive/exampleParis1/cameraCalibration.json';

                // Fetch the two files
                var promises = [];
                var networkOptions = {crossOrigin: ''};
                promises.push(itowns.Fetcher.json(orientationsUrl, networkOptions) );
                promises.push(itowns.Fetcher.json(calibrationUrl, networkOptions) ) ;
                Promise.all(promises).then((res) => {

                    var orientation = res[0];
                    var calibration = res[1];

                    // Create oriented image layer
                    olayer = new itowns.OrientedImageLayer('demo_orientedImage', {
                        // Radius in meter of the sphere used as a background.
                        backgroundDistance: 450,
                        source: orientedImageSource,
                        orientation: orientation,
                        calibration: calibration,
                        projection: view.referenceCrs,
                        onPanoChanged: (e) => {
                        /*    view.controls.setPreviousPosition(e.previousPanoPosition);
                            view.controls.setCurrentPosition(e.currentPanoPosition);
                            view.controls.setNextPosition(e.nextPanoPosition);
                        */    }
                    });

                    // when oriented image layer is ready..
                    view.addLayer(olayer, view.tileLayer).then(function addWfsLayer(orientedImageLayer) {
                    
                        // prepare WFS source for the buildings
                        var wfsBuildingSource = new itowns.WFSSource({
                            url: 'https://wxs.ign.fr/3ht7xcw6f7nciopo16etuqp2/geoportail/wfs?',
                            version: '2.0.0',
                            typeName: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie,BDTOPO_BDD_WLD_WGS84G:bati_industriel',
                            projection: 'EPSG:4326',
                            ipr: 'IGN',
                            format: 'application/json',
                            zoom: { min: 15, max: 15 },
                        });

                        // create geometry layer for the buildings
                        var wfsBuildingLayer = new itowns.GeometryLayer('Buildings', new itowns.THREE.Group(), {
                            update: itowns.FeatureProcessing.update,
                            convert: itowns.Feature2Mesh.convert({
                                altitude: altitudeBuildings,
                                extrude: extrudeBuildings }),

                            // when a building is created, it get the projective texture mapping, from oriented image layer.
                            onMeshCreated: (mesh) => mesh.traverse(object => object.material = orientedImageLayer.material),
                            source: wfsBuildingSource,
                            overrideAltitudeInToZero: true,
                        });

                        // add the created building layer, and debug UI
                        view.addLayer(wfsBuildingLayer).then(function addDebugUI(buildingLayer) {
                            var gui = debug.GeometryDebug.createGeometryDebugUI(menuGlobe.gui, view, buildingLayer);
                            debug.GeometryDebug.addWireFrameCheckbox(gui, view, buildingLayer);
                        });

                        // Test to project on a 3D model
                        // model.traverse(function _(obj) { obj.material = olayer.material; });
                    });

                 //   view.camera.camera3D.position.copy({x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});
                    view.notifyChange(view.camera.camera3D);
            /*        // set camera to current panoramic
                    view.controls.setCameraToCurrentPosition();
                    view.controls.moveCameraVertical(0.85);
                    view.notifyChange(view.camera.camera3D);
                    console.log(view.controls);
                    console.log(view.camera.camera3D);
                */    
                    console.log(olayer);
                 //   model.traverse(function _(obj) { obj.material = olayer.material; });
                    }
                
                    

                );
            }


            function centerCameraStreetView(){
                view.camera.camera3D.position.copy({x: 4200418.678760414, y: 169697.9663647849, z: 4780662.507142361});//{x: 4199575.751513691, y: 170654.7421699525, z: 4781364.212254677});  //{x: 4199779.782905031, y: 171024.8334730191, z: 4781177.511110922}); // {x: 4199820.888875769, y: 171052.74504265454, z: 4781140.971902925}); //{x: 4199825.822840914, y: 172469.5643900863, z: 4781089.122163953}); //{x: 4200557.133126016, y: 172016.98119668392, z: 4780462.11547708});//{x: 4200012.882959826, y: 173338.79678516634, z: 4780896.915537954});//{x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});//{x: 4202444.187983729, y: 172504.46625564503, z: 4778798.559683817});//{x: 4199402.418293162, y: 170632.28074215917, z: 4781516.8235254865});//{x: 4200455.75402067, y: 173453.53384993714, z: 4780501.335775498});
                view.notifyChange(view.camera.camera3D);
            }



            // add debugging tools to GUI
            var d = new debug.Debug(view, menuGlobe.gui);
            debug.createTileDebugUI(menuGlobe.gui, view, view.tileLayer, d);


            // Ugly way to force refreshing the view 
            var time = 0;
            function updateView() {
               time++;
               if(time % 100 == 0){
                    view.notifyChange(view.camera.camera3D);
                    //console.log(view.controls);
               }
               window.requestAnimationFrame(updateView); 
            }

            updateView();


            for (var layer of view.getLayers()) {
               
                if (layer.id === 'WFS Building') {
                    layer.whenReady.then( function _(layer) {
                        var gui = debug.GeometryDebug.createGeometryDebugUI(menuGlobe.gui, view, layer);
                        debug.GeometryDebug.addWireFrameCheckbox(gui, view, layer);
                    });
                }
            }


        // Dirty little functions to show rays from ground points to camera through image
        function showFaisceaux(){
            var source = new FetchSource('../data/');
            
            source.open('MesuresAppuis-S2D.xml', 'text').then(
                function(data){
                    parser = new DOMParser();
                    xmlDoc = parser.parseFromString(data,"text/xml");
                    var g = xmlToJson(xmlDoc);//JSON.stringify(data));
                    console.log(g);
                    
                    // We load the second file of ground points
                    var sourceG = new FetchSource('../data/');
                    sourceG.open('appuis.xml', 'text').then(
                        function(dataG){
                            xmlDocG = parser.parseFromString(dataG,"text/xml");
                            var g2 = xmlToJson(xmlDocG);//JSON.stringify(data));
                            console.log(g2);
                            
                            // We draw spheres on points appuis
                            var pG = g2.DicoAppuisFlottant.OneAppuisDAF;
                            for(var i = 0; i < pG.length; ++i){
                                var imageNameCurrent = "";
                                var coordAssociatedCamera;
                                var pos = pG[i].Pt["#text"].split(" "); //.split(" ");
                                //console.log(pos);
                                var coord = new itowns.Coordinates('EPSG:2154', parseFloat(pos[0]), parseFloat(pos[1]), parseFloat(pos[2]));
                                var coordInSys = coord.as(view.referenceCrs);
                                //  console.log(pos, coordInSys);
                                var namePt = pG[i].NamePt["#text"];
                               // console.log(namePt);
                                
                                var mesAppuis = g.SetOfMesureAppuisFlottants.MesureAppuiFlottant1Im;
                                for(var j =0; j < mesAppuis.length; ++j){
                                    //console.log(mesAppuis[j]);
                                    var keys = Object.keys( mesAppuis[j].NameIm );
                                    var nameImage2 = mesAppuis[j].NameIm[keys[0]];//mesAppuis[j].NameIm;

                                    // When we encounter the good id of ground point we save image name and look the the right camera
                                    var allMeasures = mesAppuis[j].OneMesureAF1I;
                                    for(var k = 0; k < allMeasures.length; ++k){
                                        var namePtLocal = allMeasures[k].NamePt["#text"];
                                        //console.log(namePtLocal);
                                        if(namePtLocal == namePt){
                                            imageNameCurrent = nameImage2;
                                           // console.log("imageNameCurrent",imageNameCurrent);
                                            var cutNameCurrent = imageNameCurrent.substring(imageNameCurrent.indexOf(".tif") -12, imageNameCurrent.indexOf(".tif") );
                                            // We then need to associate the good camera
                                            var sceneCAMS = sceneAllCams.children;
                                            for(var z = 0; z < sceneCAMS.length; ++z){
                                                //console.log("sceneCAMS.name", sceneCAMS[z].name);
                                                var cutName = sceneCAMS[z].name.substring(sceneCAMS[z].name.indexOf(".jp2") -12, sceneCAMS[z].name.indexOf(".jp2") );
                                                //console.log(cutName);
                                                if (cutName == cutNameCurrent){
                                                    coordAssociatedCamera = sceneCAMS[z].position;
                                                    console.log("aaaaaaaaaaaaaaaaaaaaaaa", cutName, coordAssociatedCamera);
                                                }
                                                
                                            }
                                        }
                                    }

                                    //console.log(nameImage2);
                                }
                                // Super ugly: we now look to associate the namePT tothe image in the previous xml loaded

                                // position of cam for ray: coordAssociatedCamera

                                // Draw sphere at pos
                                var geometry = new itowns.THREE.SphereGeometry( 10, 6, 6 );
                                var col = new itowns.THREE.Color(0XFFFF00);
                                var material = new itowns.THREE.MeshBasicMaterial( {color: new itowns.THREE.Color(0XFF0000), transparent:true, opacity:0.8} );
                                var sphere = new itowns.THREE.Mesh( geometry, material );
                                sphere.position.set(coordInSys.x, coordInSys.y, coordInSys.z); //console.log(sphere.position);
                                sphere.updateMatrixWorld();
                                view.scene.add( sphere );


                                // RAY
                                var material = new THREE.LineBasicMaterial({
                                    color: 0x0000ff
                                });

                                var geometry = new THREE.Geometry();
                                geometry.vertices.push(
                                    coordAssociatedCamera,
                                    sphere.position
                                );

                                var line = new THREE.Line( geometry, material );
                                view.scene.add( line );
                    
                                
                            }
                            view.notifyChange();
                        }
                    );
                }
            );
            console.log("sceneAllCams", sceneAllCams);
        }

        // Changes XML to JSON
            function xmlToJson(xml) {
                
                // Create the return object
                var obj = {};

                if (xml.nodeType == 1) { // element
                    // do attributes
                    if (xml.attributes.length > 0) {
                    obj["@attributes"] = {};
                        for (var j = 0; j < xml.attributes.length; j++) {
                            var attribute = xml.attributes.item(j);
                            obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
                        }
                    }
                } else if (xml.nodeType == 3) { // text
                    obj = xml.nodeValue;
                }

                // do children
                if (xml.hasChildNodes()) {
                    for(var i = 0; i < xml.childNodes.length; i++) {
                        var item = xml.childNodes.item(i);
                        var nodeName = item.nodeName;
                        if (typeof(obj[nodeName]) == "undefined") {
                            obj[nodeName] = xmlToJson(item);
                        } else {
                            if (typeof(obj[nodeName].push) == "undefined") {
                                var old = obj[nodeName];
                                obj[nodeName] = [];
                                obj[nodeName].push(old);
                            }
                            obj[nodeName].push(xmlToJson(item));
                        }
                    }
                }
                return obj;
            };


        // Create depth map for registered images
        // It's dissociated between tile geometry and buildings... So we mix 2 technics
        function createDepthMap(){
            // itowns.renderViewToBuffer(view);
            // view.scene.overrideMaterial = new THREE.MeshDepthMaterial();
            // view.mainLoop.gfxEngine.renderer.shadowMap.enabled = true;
                 view.mainLoop.gfxEngine.renderer.preserveDrawingBuffer = true;
                 view.mainLoop.gfxEngine.renderer.autoClear = false;
                 view.mainLoop.gfxEngine.renderer.preserveDrawingBuffer = true;
                 var aspect =     view.camera.camera3D.aspect;
                 var fov =     view.camera.camera3D.fov;
                 var far =     view.camera.camera3D.far;
                 var near =     view.camera.camera3D.near;

                    view.camera.camera3D.aspect = camera.aspect;
                    view.camera.camera3D.fov = camera.fov;
                    view.camera.camera3D.near = nearProj;
                    view.camera.camera3D.far = farProj;
                    view.camera.camera3D.updateProjectionMatrix();

                  //  view.camera.camera3D.projectionMatrix = camera.preProjectionMatrix;
                    //view.scene.remove(globalCurrentCamOriented);
                    globalCurrentCamOriented.visible = false;
                 //   view.camera.camera3D.projectionMatrix = camera.projectionMatrix;
                 //   view.notifyChange(view.camera.camera3D);
                 //   view.camera.camera3D.updateProjectionMatrix();
                    // Create a multi render target with Float buffers
                    target = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
                    target.texture.format = THREE.RGBFormat;
                    target.texture.minFilter = THREE.NearestFilter;
                    target.texture.magFilter = THREE.NearestFilter;
                    target.texture.generateMipmaps = false;
                    target.stencilBuffer = false;
                    target.depthBuffer = true;
                    target.depthTexture = new THREE.DepthTexture();
                    target.depthTexture.type = THREE.UnsignedShortType;
                    view.notifyChange(view.camera.camera3D);
                    // render scene into target 
                  //  console.log(view.mainLoop.gfxEngine.renderer);
                    view.mainLoop.gfxEngine.renderer.setRenderTarget( target );
                    view.mainLoop.gfxEngine.renderer.render( view.scene, view.camera.camera3D );
                    //var texture = new THREE.DataTexture( buffer, view.camera.width, view.camera.height, THREE.RGBAFormat );
                    //texture.needsUpdate = true;
                    //textureMaterial.map = target.depthTexture;//texture//depthTexture;
                  //  textureMaterial.tDepth = target.depthTexture;
                    textureMaterial.uniforms.tDepth.value = target.depthTexture;
                    //textureMaterial.uniforms.foggy.value = 1.;
                    //view.notifyChange(view.camera.camera3D);
                    // Back to original cam
                    view.camera.camera3D.aspect = aspect;
                    view.camera.camera3D.fov = fov;
                    view.camera.camera3D.near = near;
                    view.camera.camera3D.far = far;
                    view.camera.camera3D.updateProjectionMatrix();

                    globalCurrentCamOriented.visible = true;
                    view.mainLoop.gfxEngine.renderer.setRenderTarget(null);
                    view.notifyChange(view.camera.camera3D);

        }    


        // SAVE THE DEPTH MAP FOR RE-USE AND OFFLINE USE 
        function saveDepthMap(){
            target = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight );
            target.texture.format = THREE.RGBFormat;
            target.texture.minFilter = THREE.NearestFilter;
            target.texture.magFilter = THREE.NearestFilter;
            target.texture.generateMipmaps = false;
            target.stencilBuffer = false;
            target.depthBuffer = true;
            target.depthTexture = new THREE.DepthTexture();
            target.depthTexture.type = THREE.UnsignedShortType;
            view.mainLoop.gfxEngine.renderer.render( view.scene, view.camera.camera3D );

            var img = view.mainLoop.gfxEngine.bufferToImage(target.texture, window.innerWidth, window.innerHeight);
            document.getElementById('miniDiv').appendChild(img);
            //console.log(target);
            /*
            var dataURL = view.mainLoop.gfxEngine.renderer.domElement.toDataURL();
            var img = new Image();
            img.src = dataURL;
            //console.log(img);
            document.getElementById('miniDiv').appendChild(img);
            */
                
        }
        
        // Save scene to image in local
        function saveAsImageLocally() {
            var imgData, imgNode;
            var strDownloadMime = "image/octet-stream";
            try {
                var strMime = "image/jpeg";
                view.mainLoop.gfxEngine.renderView(view);
                imgData = view.mainLoop.gfxEngine.renderer.domElement.toDataURL(strMime);
                saveFile(imgData.replace(strMime, strDownloadMime), "test.jpg");
            } catch (e) {
                console.log(e);
                return;
            }
        }

        var saveFile = function (strData, filename) {
            var link = document.createElement('a');
            if (typeof link.download === 'string') {
                document.body.appendChild(link); //Firefox requires the link to be in the body
                link.download = filename;
                link.href = strData;
                link.click();
                document.body.removeChild(link); //remove the link when done
            } else {
                location.replace(uri);
            }
        }


        // Save scene to image on the server and launch AUTO REGISTRATION
        function saveAsImageToServer() {
            var imgData, imgNode;
            var strDownloadMime = "image/octet-stream";
            try {
               // var strMime = "image/png";
                view.mainLoop.gfxEngine.renderView(view);
                imgData = view.mainLoop.gfxEngine.renderer.domElement.toDataURL("image/png");
                var imgImportedName = document.getElementById('img').src.split('/').pop();
                saveFileToServer(imgData, imgImportedName);
            } catch (e) {
                console.log(e);
                return;
            }
        }

        var saveFileToServer = function (strData, filename) {

            $.ajax({
                type: "POST",
                url: "writeImageToServer.php",
                data: { 
                    imgBase64: strData,
                    imgName: filename
                }
            }).done(function(response) {
                console.log('saved: ' + response); 
                // We can then reproject homologues points into the scene and launch Aspro!
                readAppariement();
            });

        }

        
        // Function that reads appariement results and get 3D point and write both gcp.xml and appuis.xml
        function readAppariement(){
            // Default url for results: http://134.158.74.36/alegoriaX/src/pts_image1_image2.resultfiltre
            jQuery.get('pts_image1_image2.resultfiltre', function(data) {
                console.log(data);
                arrAppariement = data.split(/\s+/);
                console.log(arrAppariement);  // Xa0,Ya0,Xb0,Yb0,Xa1,Ya1,...,Xan,Yan,Xbn,Ybn

                // We then launch the creation of the GCP and Appuis files
                createHomologuePointFiles();
            });

        }

       
        // We reproject the 2D points homologues in the Scene to get 3D coordinates
        function createHomologuePointFiles(){
            for(var i = 0; i < arrAppariement.length -1; i+=4){
                
                var pScene = {x:Number(arrAppariement[i]), y: Number(arrAppariement[i + 1])};
                var pPhoto = {x:Number(arrAppariement[i + 2]), y: Number(arrAppariement[i + 3])};
                var pickBuilding = pickingBuildings(pScene);
                var geoposition = new THREE.Vector3();
                if(pickBuilding.z == 0){
                    // get 3D coordinates on ground
                    geoposition = view.controls.pickGeoPosition(new itowns.THREE.Vector2(pScene.x, pScene.y));
                    // convert coordinates to geographic system
                    if(typeof geoposition != "undefined"){
                        var converted = geoposition.as('EPSG:4978'); // console.log(converted);
                        //coordinates = converted._values;
                        pickBuilding.x = converted.x;
                        pickBuilding.y = converted.y;
                        pickBuilding.z = converted.z;
                    }
                }
                //if(pick)
                console.log(pickBuilding, pScene);
                if(pickBuilding.z !==0){
                    show3DPicking(pickBuilding.x, pickBuilding.y, pickBuilding.z, ptname);
                    // export 3D coordinates to an xml file
                    export3Dcoord(ptname, pickBuilding.x, pickBuilding.y, pickBuilding.z);
                    export2DCoord(ptname, pPhoto.x, pPhoto.y);
                    ptname++;
                }
            }

            // We can finally now launch Aspro
            setTimeout(function() {   // Ugly timer cause src change/affectation takes time and no callback used
                    computeResection({}, document.getElementById('img').src.split('/').pop(), true);
                }, 650);
            //computeResection({}, document.getElementById('img').src.split('/').pop(), false);
        }

/*      
        function load3DModel(){
             // ThreeLoader can load each format proposed in ThreeJs examples loaders : https://github.com/mrdoob/three.js/tree/dev/examples/js/loaders
              var promiseCollada = ThreeLoader.load('GLTF', 'alexPont.glb')
                .then(collada => {
                    model = collada.scene;

                    // building coordinate
                    var coord = new itowns.Coordinates('EPSG:4326', 2.36381, 48.86754, 30);
                    var colladaID = view.mainLoop.gfxEngine.getUniqueThreejsLayer();

                    model.position.copy(coord.as(view.referenceCrs));
                    // align up vector with geodesic normal
                    model.lookAt(model.position.clone().add(coord.geodesicNormal));
                    // user rotate building to align with ortho image
                    model.rotateX(Math.PI / 2);
                    model.rotateY(1.32 * Math.PI / 2);
                    model.scale.set(1., 1., 1.);

                    // set camera's layer to do not disturb the picking
                    model.traverse(function _(obj) { obj.layers.set(colladaID); });
                    //model.traverse(function _(obj) { obj.material = orientedImageLayer.material; });
                    view.camera.camera3D.layers.enable(colladaID);

                    // update coordinate of the mesh
                    model.updateMatrixWorld();

                    view.scene.add(model);
                    var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
                    light.position.copy(coord.as(view.referenceCrs));
                    light.position.addScalar(30);
                    light.updateMatrixWorld();
                    view.scene.add( light ); 
                    view.notifyChange();
                });
        }
*/

        /*********** Keyboard/Mouse functions for preview of orientation ********************/
            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();

            function onMouseMove( event ) {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                // update the picking ray with the camera and mouse position
	            raycaster.setFromCamera( mouse, view.camera.camera3D );
                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects(sceneAllCams.children, true);  // "true" for recursive raycast
                if(intersects.length && intersects.length > 0){
                    activateCamHelper(intersects[ 0 ].object.parent);
                    firstMoveOut = true;
                }
               
                if (intersects.length == 0 && firstMoveOut && !scalingOffisOn){
                    firstMoveOut = false;
                    scalingOffCamHelpers();
                }
            }

            function onMouseClick( event ){
                var mouse = new THREE.Vector2();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                // update the picking ray with the camera and mouse position
	            raycaster.setFromCamera( mouse, view.camera.camera3D );
                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects(sceneAllCams.children, true);  // "true" for recursive raycast
                if (intersects.length && intersects.length > 0){
                    // We put the scene camera like was the camera that took the selected photo
                    console.log("cliiiick", intersects[ 0 ].object.parent);
                    handleOrientation(intersects[ 0 ].object.parent.parent);
                }
                /*
                for ( var i = 0; i < intersects.length; i++ ) {
                    
                    // We put the scene camera like was the camera that took the selected photo
                    console.log("cliiiick", intersects[ i ].object.parent);
                    handleOrientation(intersects[ i ].object.parent.parent);
                }
                */
            }

            window.addEventListener( 'mousemove', onMouseMove, false );
            window.addEventListener('mousedown', e => {
                positionMouseDown = new THREE.Vector2(e.clientX, e.clientY); 
                mouseDown = true;
            });
            window.addEventListener('mouseup', e => {
                mouseDown = false;
                if(positionMouseDown.distanceTo(new THREE.Vector2(e.clientX, e.clientY)) < 2)
                    onMouseClick(e);
            });
          
            window.addEventListener('wheel', event => {mouseWheelOn = true;});

            // Function to show dynamically the camHelper under the mouse
            function activateCamHelper(obj){
                currentObjUnderMouse = obj;  // console.log("undermouse: ",obj);
                textureMaterial = obj.children[0].material[1];
                scaleCamHelper();
            }


            function scaleCamHelper(){
                
               if(currentObjUnderMouse.scale.x < 10){
                    currentObjUnderMouse.scale.addScalar(0.4);
                    currentObjUnderMouse.updateMatrixWorld();
                    view.notifyChange();
                    requestAnimationFrame( scaleCamHelper );
                }
            }


            function scalingOffCamHelpers(){ 
                scalingOffisOn = true;
                // console.log('scalingOff', nbToModify);
                nbToModify = 0;
                for(var i = 0; i < sceneAllCams.children.length; ++i){
                    var o = sceneAllCams.children[i].children[0];
                   if(o.scale.x > 4){
                        o.scale.addScalar(-0.4);
                        o.updateMatrixWorld();
                        view.notifyChange();
                        nbToModify = 1;
                    }
                }
                if(nbToModify > 0){
                    scaleOff = true;
                    requestAnimationFrame( scalingOffCamHelpers );
                }       
                else{
                    firstMoveOut = false; scaleOff = false; scalingOffisOn = false;
                }
            }
            

            document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                evt = event;
                var target = evt.target || evt.srcElement;
                var targetTagName = (target.nodeType == 1) ? target.nodeName.toUpperCase() : "";
                //console.log(evt, targetTagName);

                if(evt.key == "Enter") {  // We use geocoder...
                    
                    var lieu = document.getElementById("nameLocation").value;
                    testGeocoding(lieu);
                    
                }

                if ( !/INPUT|SELECT|TEXTAREA/.test(targetTagName) ) { 

                        
                    if(keyName === 'r') {
                        if(!previewOn){
                            previewOn = true;
                            // save current scene camera position
                            currentCameraScene = {quaternion: view.camera.camera3D.quaternion.clone(), scale: view.camera.camera3D.scale.clone(), position: view.camera.camera3D.position.clone()};
                            //console.log(currentCameraScene);
                            // Launch preview of last computed orientation
                            previewResection();
                        }
                    }

                }


            }, false);



            console.log(document.activeElement);
            document.addEventListener('mouseup', (event) => {
                //document.focus();
            }, false);

    /*     
            document.addEventListener('keyup', (event) => {
                const keyName = event.key;
                if(keyName === 'r') {

                  //  createDepthMap();
                    previewOn = false;
                    setupViewCameraDecomposing(view, currentCameraScene);
                }
            }, false);

            document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 's') {
                    //saveDepthMap();
                    activateStreetLevel();
                }
            }, false);

            document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 'k') {
                    //saveDepthMap();
                    //saveAsImageLocally();
                    saveAsImageToServer();
                }
            }, false);
            
            document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 'w') {
                    //saveDepthMap();
                    //saveAsImageLocally();
                    readAppariement();
                }
            }, false);
          
            
              //Keyboard functions for preview of orientation 
              document.addEventListener('keydown', (event) => {
                const keyName = event.key;
                if(keyName === 'c') {
                    centerCameraStreetView();
                }
            }, false);
    */


            // OrientedImage Helper from iTowns Examples JS code is now here and should be in a separate class but without itowns dep
            /* global itowns, document */

            // set object position to the coordinate
            // set object ENH orientation: X to the east, Y (green) to the north, Z (blue) look to the sky.
            function placeObjectFromCoordinate(object, coord) {
                // set object position to the coordinate
                coord.xyz(object.position);
                // set ENH orientation, looking at the sky (Z axis), so Y axis look to the north..
                object.lookAt(coord.geodesicNormal.clone().add(object.position));
            }

            function createTexturedPlane(textureUrl, opacity) {
                var texture;
                var geometry;
                var material;

                texture = new itowns.THREE.TextureLoader().load(textureUrl);
                geometry = new itowns.THREE.PlaneGeometry(1, 1, 32);
                material = new itowns.THREE.MeshBasicMaterial({
                    map: texture,
                    color: 0xffffff,
                    transparent: true,
                    opacity: opacity,
                });
                return new itowns.THREE.Mesh(geometry, material);
            }

            function transformTexturedPlane(camera, distance, plane) {
                var Yreel = 2 * Math.tan(itowns.THREE.Math.degToRad(camera.fov / 2)) * distance;
                var Xreel = camera.aspect * Yreel;

                // set position and scale
                plane.scale.set(Xreel, Yreel, 1);
                plane.position.set(0, 0, -distance);

                plane.updateMatrixWorld();
            }

            // eslint-disable-next-line no-unused-vars
            function initCamera(view, image, coord, EnhToOrientationUp, EnhToOrientationLookAt, rotMatrix,
                orientationToCameraUp, orientationToCameraLookAt, distance, size, focale) {
                var fov = itowns.THREE.Math.radToDeg((2 * Math.atan((size[1] / 2) / focale)));
                var coordView;
                var localSpace;
                var orientedImage;
                var quaternion;
                var camera;

                coordView = coord.as(view.referenceCrs);

                // create 'local space', with the origin placed on 'coord',
                // with Y axis to the north, X axis to the east and Z axis as the geodesic normal.
                localSpace = new itowns.THREE.Object3D();
                view.scene.add(localSpace);
                placeObjectFromCoordinate(localSpace, coordView);

                // add second object : 'oriented image'
                orientedImage = new itowns.THREE.Object3D();
                // setup initial convention orientation.
                orientedImage.up.copy(EnhToOrientationUp);
                orientedImage.lookAt(EnhToOrientationLookAt);

                // place the 'oriented image' in the 'local space'
                localSpace.add(orientedImage);

                // apply rotation
                quaternion = new itowns.THREE.Quaternion().setFromRotationMatrix(rotMatrix);
                orientedImage.quaternion.multiply(quaternion);
                // orientedImage.updateMatrixWorld();

                // create a THREE JS Camera
                camera = new itowns.THREE.PerspectiveCamera(fov, size[0] / size[1], distance / 2, distance * 2);
                camera.up.copy(orientationToCameraUp);
                camera.lookAt(orientationToCameraLookAt);

                orientedImage.add(camera);

                localSpace.updateMatrixWorld(true);
                return camera;
            }

            // eslint-disable-next-line no-unused-vars
            function setupPictureFromCamera(camera, imageUrl, opacity, distance) {
                // create a textured plane, representing the picture.
                var plane = createTexturedPlane(imageUrl, opacity);
                camera.add(plane);

                transformTexturedPlane(camera, distance, plane);

                return plane;
            }

            // set camera settings to view.camera,
            // BUT keep the geodesic normal as Up vector
            // eslint-disable-next-line no-unused-vars
            function setupViewCameraLookingAtObject(camera, coord, objectToLookAt) {
                camera.position.copy(coord.xyz());
                camera.up.copy(coord.geodesicNormal);
                camera.lookAt(objectToLookAt.getWorldPosition());
            }

            // set camera settings to view.camera, even the up vector !
            // eslint-disable-next-line no-unused-vars
            function setupViewCameraDecomposing(view, camera) {
                mouseWheelOn = false;
                //camera.matrixWorld.decompose(viewCamera.position, viewCamera.quaternion, viewCamera.scale);
                t = 0;
                interpolateCam(view, camera);
            }

            var t = 0;
            var inc = 0.004;
            function interpolateCam(view, camera){
                if(t < 1. && !mouseWheelOn){
                    var viewCamera = view.camera.camera3D;
                    viewCamera.quaternion.slerp( camera.quaternion, t += inc );
                    viewCamera.position.lerp( camera.position, t += inc );
                    viewCamera.scale.lerp( camera.scale, t += inc );
                    view.notifyChange();
                    requestAnimationFrame(function(){interpolateCam(view,camera);});
                }
            }

            // add a camera helper to debug camera position..
            // eslint-disable-next-line no-unused-vars
            function addCameraHelper(view, camera) {
                var cameraHelper = new itowns.THREE.CameraHelper(camera);
                view.scene.add(cameraHelper);
                cameraHelper.updateMatrixWorld(true);
            }


            // Filtering functions
            function filterDates(t0, t1){
                //console.log(sceneAllCams);
                var cams = sceneAllCams.children;
                for(var i in cams){
                    var cam = cams[i];
                    var t0Cam = new Date(cam.propAdded.t0);
                    var year = 1900 + t0Cam.getYear();
                    //console.log(year, t0);
                    if(Math.abs(year - t0) < 1){
                        cam.visible = true;
                    }else{
                        cam.visible = false;
                    }
                   
                }
            }


        </script>
    </body>
</html>
